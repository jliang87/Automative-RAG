"""
Streamlit ÁïåÈù¢ UI ÁªÑ‰ª∂ - ÁÆÄÂåñÁâàÊú¨Áî®‰∫éËá™Ëß¶Âèë‰Ωú‰∏öÈìæÊû∂ÊûÑ

ËØ•Ê®°ÂùóÂåÖÂê´ Streamlit Â∫îÁî®Á®ãÂ∫è‰∏≠ÁöÑÂèØÂ§çÁî® UI ÁªÑ‰ª∂„ÄÇ
‰∏ì‰∏∫Ëá™Ëß¶Âèë‰Ωú‰∏öÈìæÂíå‰∏ìÁî®WorkerÊû∂ÊûÑ‰ºòÂåñ„ÄÇ
"""

import streamlit as st
import httpx
from typing import Dict, List, Optional, Union, Callable, Any
# Fix for Arrow serialization errors - Add this to components.py or create a new utils file
import pandas as pd

# ÂØºÂÖ•Áªü‰∏ÄÁöÑ API ÂÆ¢Êà∑Á´Ø
from src.ui.api_client import api_request


def header(title: str, description: Optional[str] = None):
    """ÊòæÁ§∫È°µÈù¢Ê†áÈ¢òÂíåÊèèËø∞"""
    st.title(title)
    if description:
        st.markdown(description)
    st.divider()


def api_status_indicator():
    """ÊòæÁ§∫ API ËøûÊé•Áä∂ÊÄÅ"""
    try:
        with httpx.Client() as client:
            response = client.get(
                f"{st.session_state.api_url}/health",
                headers={"x-token": st.session_state.api_key},
                timeout=3.0
            )

        if response.status_code == 200:
            st.sidebar.success("‚úÖ API ËøûÊé•Ê≠£Â∏∏")
            return True
        else:
            st.sidebar.error(f"‚ùå API ÈîôËØØ: {response.status_code}")
            return False
    except Exception as e:
        st.sidebar.error(f"‚ùå ËøûÊé•Â§±Ë¥•: {str(e)}")
        return False


def metadata_filters():
    """Ê∏≤ÊüìÂÖÉÊï∞ÊçÆÁ≠õÈÄâÈÄâÈ°π"""
    st.subheader("Á≠õÈÄâÊù°‰ª∂")

    col1, col2 = st.columns(2)

    with col1:
        # Ëøô‰∫õÈÄâÈ°πÂ∫îËØ•‰ªé API Ëé∑Âèñ
        manufacturers = ["", "‰∏∞Áî∞", "Êú¨Áî∞", "Á¶èÁâπ", "ÂÆùÈ©¨", "ÁâπÊñØÊãâ"]
        manufacturer = st.selectbox("ÂéÇÂïÜ", manufacturers)

        years = [""] + [str(year) for year in range(2010, 2026)]
        year = st.selectbox("Âπ¥‰ªΩ", years)

        categories = ["", "ËΩøËΩ¶", "SUV", "Âç°ËΩ¶", "Ë∑ëËΩ¶", "MPV"]
        category = st.selectbox("ËΩ¶Âûã", categories)

    with col2:
        models = [""]
        if manufacturer == "‰∏∞Áî∞":
            models += ["ÂáØÁæéÁëû", "Âç°ÁΩóÊãâ", "RAV4", "Ê±âÂÖ∞Ëææ"]
        elif manufacturer == "Êú¨Áî∞":
            models += ["ÊÄùÂüü", "ÈõÖÈòÅ", "CR-V", "Pilot"]
        elif manufacturer == "Á¶èÁâπ":
            models += ["ÈáéÈ©¨", "F-150", "Êé¢Èô©ËÄÖ", "Escape"]
        elif manufacturer == "ÂÆùÈ©¨":
            models += ["3Á≥ª", "5Á≥ª", "X3", "X5"]
        elif manufacturer == "ÁâπÊñØÊãâ":
            models += ["Model S", "Model 3", "Model X", "Model Y"]

        model = st.selectbox("ËΩ¶Âûã", models)

        engine_types = ["", "Ê±ΩÊ≤π", "Êü¥Ê≤π", "ÁîµÂä®", "Ê∑∑ÂêàÂä®Âäõ"]
        engine_type = st.selectbox("ÂèëÂä®Êú∫Á±ªÂûã", engine_types)

        transmission_types = ["", "Ëá™Âä®", "ÊâãÂä®", "CVT", "DCT"]
        transmission = st.selectbox("ÂèòÈÄüÁÆ±", transmission_types)

    # ÊûÑÂª∫Á≠õÈÄâÊù°‰ª∂
    metadata_filter = {}

    if manufacturer:
        metadata_filter["manufacturer"] = manufacturer
    if model:
        metadata_filter["model"] = model
    if year:
        metadata_filter["year"] = int(year)
    if category:
        metadata_filter["category"] = category
    if engine_type:
        metadata_filter["engine_type"] = engine_type
    if transmission:
        metadata_filter["transmission"] = transmission

    return metadata_filter if metadata_filter else None


def display_document(doc: Dict, index: int):
    """Â±ïÁ§∫ÊêúÁ¥¢ÁªìÊûúÊñáÊ°£"""
    metadata = doc.get("metadata", {})

    # Á°ÆÂÆöÊù•Ê∫êÂõæÊ†á
    source_type = metadata.get("source", "Êú™Áü•")
    source_icon = "üìö"
    if source_type == "youtube":
        source_icon = "üé¨"
    elif source_type == "pdf":
        source_icon = "üìÑ"
    elif source_type == "manual":
        source_icon = "üìù"

    title = metadata.get("title", f"ÊñáÊ°£ {index+1}")

    with st.expander(f"{source_icon} {title}"):
        st.caption(f"Êù•Ê∫ê: {source_type}")
        st.caption(f"Áõ∏ÂÖ≥Â∫¶: {doc.get('relevance_score', 0):.4f}")

        auto_info = [metadata.get("manufacturer", ""), metadata.get("model", ""), str(metadata.get("year", ""))]
        st.markdown(f"**ËΩ¶Âûã**: {' '.join([x for x in auto_info if x])}")

        st.markdown("---")
        st.markdown(doc.get("content", ""))

        if metadata.get("url"):
            st.markdown(f"[ÂéüÂßãÈìæÊé•]({metadata['url']})")


def loading_spinner(text: str = "Â§ÑÁêÜ‰∏≠..."):
    """ÂàõÂª∫Âä†ËΩΩÂä®Áîª"""
    return st.spinner(text)


def job_chain_status_card(job_data: Dict[str, Any]):
    """ÊòæÁ§∫‰Ωú‰∏öÈìæÁä∂ÊÄÅÂç°Áâá"""
    job_id = job_data.get("job_id", "")
    status = job_data.get("status", "")
    job_type = job_data.get("job_type", "")

    # Áä∂ÊÄÅÈ¢úËâ≤Êò†Â∞Ñ
    status_colors = {
        "pending": "üü°",
        "processing": "üîµ",
        "completed": "üü¢",
        "failed": "üî¥"
    }

    status_icon = status_colors.get(status, "‚ö™")

    with st.container():
        col1, col2, col3 = st.columns([2, 1, 1])

        with col1:
            st.markdown(f"**{status_icon} {job_id[:8]}...**")
            st.caption(f"Á±ªÂûã: {job_type}")

        with col2:
            st.markdown(f"**Áä∂ÊÄÅ**")
            st.caption(status)

        with col3:
            if st.button("ËØ¶ÊÉÖ", key=f"details_{job_id}"):
                st.session_state.selected_job_id = job_id
                st.rerun()


def worker_health_indicator():
    """ÊòæÁ§∫‰∏ìÁî®WorkerÂÅ•Â∫∑Áä∂ÊÄÅÊåáÁ§∫Âô®"""
    health_data = api_request(
        endpoint="/system/health/detailed",
        method="GET",
        silent=True
    )

    if not health_data:
        st.warning("‚ö†Ô∏è Êó†Ê≥ïËé∑ÂèñWorkerÁä∂ÊÄÅ")
        return

    workers = health_data.get("workers", {})

    # ÊåâWorkerÁ±ªÂûãÂàÜÁªÑ
    worker_types = {
        "gpu-whisper": {"name": "üéµ ËØ≠Èü≥ËΩ¨ÂΩï", "workers": []},
        "gpu-embedding": {"name": "üî¢ ÂêëÈáèÂµåÂÖ•", "workers": []},
        "gpu-inference": {"name": "üß† LLMÊé®ÁêÜ", "workers": []},
        "cpu": {"name": "üíª CPUÂ§ÑÁêÜ", "workers": []}
    }

    # ÂàÜÁ±ªWorker
    for worker_id, info in workers.items():
        worker_type = info.get("type", "unknown")
        if worker_type in worker_types:
            worker_types[worker_type]["workers"].append((worker_id, info))

    # ÊòæÁ§∫ÊØèÁßçWorkerÁ±ªÂûãÁöÑÁä∂ÊÄÅ
    cols = st.columns(4)
    for i, (worker_type, type_info) in enumerate(worker_types.items()):
        with cols[i]:
            workers_of_type = type_info["workers"]
            healthy_count = sum(1 for _, info in workers_of_type if info.get("status") == "healthy")
            total_count = len(workers_of_type)

            if healthy_count == total_count and total_count > 0:
                st.success(f"‚úÖ {type_info['name']}")
                st.caption(f"{healthy_count}/{total_count} ÂÅ•Â∫∑")
            elif healthy_count > 0:
                st.warning(f"‚ö†Ô∏è {type_info['name']}")
                st.caption(f"{healthy_count}/{total_count} ÂÅ•Â∫∑")
            else:
                st.error(f"‚ùå {type_info['name']}")
                st.caption("‰∏çÂèØÁî®")


def safe_dataframe_display(data: List[Dict[str, Any]], hide_index: bool = True, use_container_width: bool = True):
    """
    Safely display a DataFrame with proper type conversion to avoid Arrow serialization errors.

    Args:
        data: List of dictionaries to convert to DataFrame
        hide_index: Whether to hide the DataFrame index
        use_container_width: Whether to use container width
    """
    if not data:
        st.info("Ê≤°ÊúâÊï∞ÊçÆÊòæÁ§∫")
        return

    try:
        # Create DataFrame
        df = pd.DataFrame(data)

        # Convert problematic columns to strings to avoid Arrow serialization issues
        for col in df.columns:
            # Check if column contains mixed types or objects that could cause issues
            if df[col].dtype == 'object':
                # Convert all values to strings, handling None/NaN values
                df[col] = df[col].astype(str).replace(['None', 'nan', 'NaN'], '-')
            elif df[col].dtype == 'int64':
                # Ensure integers are properly formatted
                df[col] = df[col].astype('Int64')  # Pandas nullable integer
            elif df[col].dtype == 'float64':
                # Handle float precision issues
                df[col] = df[col].round(2)

        # Display the DataFrame
        st.dataframe(df, hide_index=hide_index, use_container_width=use_container_width)

    except Exception as e:
        st.error(f"ÊòæÁ§∫Êï∞ÊçÆÊó∂Âá∫Èîô: {str(e)}")
        # Fallback: display as JSON
        st.json(data)


def clean_dataframe_for_display(df: pd.DataFrame) -> pd.DataFrame:
    """
    Clean a DataFrame to avoid Arrow serialization issues.

    Args:
        df: Input DataFrame

    Returns:
        Cleaned DataFrame safe for Streamlit display
    """
    df_clean = df.copy()

    for col in df_clean.columns:
        if df_clean[col].dtype == 'object':
            # Convert problematic object columns to strings
            df_clean[col] = df_clean[col].astype(str).replace(['None', 'nan', 'NaN'], '-')
        elif pd.api.types.is_numeric_dtype(df_clean[col]):
            # Handle numeric columns with potential null values
            if df_clean[col].isna().any():
                if pd.api.types.is_integer_dtype(df_clean[col]):
                    df_clean[col] = df_clean[col].astype('Int64')  # Nullable integer
                else:
                    df_clean[col] = df_clean[col].astype('float64')

    return df_clean


# Example usage in your existing code:
# Instead of:
# st.dataframe(pd.DataFrame(data), hide_index=True)
#
# Use:
# safe_dataframe_display(data)
#
# Or for existing DataFrames:
# df_clean = clean_dataframe_for_display(df)
# st.dataframe(df_clean, hide_index=True)

# For the specific issue in your code, update the queue display in enhanced_worker_status.py:
def safe_queue_display(queue_data: List[Dict[str, Any]]):
    """Safely display queue data avoiding Arrow serialization issues."""
    if not queue_data:
        st.info("Ê≤°ÊúâÈòüÂàóÊï∞ÊçÆ")
        return

    # Clean the data before creating DataFrame
    cleaned_data = []
    for item in queue_data:
        cleaned_item = {}
        for key, value in item.items():
            if value is None:
                cleaned_item[key] = "-"
            elif isinstance(value, (int, float)):
                cleaned_item[key] = value
            else:
                cleaned_item[key] = str(value)
        cleaned_data.append(cleaned_item)

    try:
        df = pd.DataFrame(cleaned_data)
        st.dataframe(df, hide_index=True, use_container_width=True)
    except Exception as e:
        st.error(f"ÊòæÁ§∫ÈòüÂàóÊï∞ÊçÆÊó∂Âá∫Èîô: {str(e)}")
        # Fallback to simple display
        for i, item in enumerate(cleaned_data):
            with st.expander(f"ÈòüÂàó {i + 1}"):
                for key, value in item.items():
                    st.write(f"**{key}**: {value}")